{
  "address": "0x0F85A912448279111694F4Ba4F85dC641c54b594",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IWETH",
          "name": "weth",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "EthDepositRejected",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "maker",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "takingAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "interactiveData",
          "type": "bytes"
        }
      ],
      "name": "fillOrderPostInteraction",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0xfa7d88a7fa989a50bcfa5328f9a7cee410f2b791fab02304913b830a73ace22d",
  "receipt": {
    "to": null,
    "from": "0x11799622F4D98A24514011E8527B969f7488eF47",
    "contractAddress": "0x0F85A912448279111694F4Ba4F85dC641c54b594",
    "transactionIndex": 4,
    "gasUsed": "159867",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x88af31fc67bfb5122a2d527d0fbc8a1c82d104061cf17c19091ec342bafa7482",
    "transactionHash": "0xfa7d88a7fa989a50bcfa5328f9a7cee410f2b791fab02304913b830a73ace22d",
    "logs": [],
    "blockNumber": 2373161,
    "cumulativeGasUsed": "845348",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x4200000000000000000000000000000000000006"
  ],
  "numDeployments": 1,
  "solcInputHash": "ed251cbd89dbecf3153cd00cd38a8d7d",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"EthDepositRejected\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"interactiveData\",\"type\":\"bytes\"}],\"name\":\"fillOrderPostInteraction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/helpers/WethUnwrapper.sol\":\"WethUnwrapper\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@1inch/solidity-utils/contracts/EthReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nabstract contract EthReceiver {\\n    error EthDepositRejected();\\n\\n    receive() external payable {\\n        _receive();\\n    }\\n\\n    function _receive() internal virtual {\\n        // solhint-disable-next-line avoid-tx-origin\\n        if (msg.sender == tx.origin) revert EthDepositRejected();\\n    }\\n}\\n\",\"keccak256\":\"0xcd7602ad72e6b142111304be5dc322ccdca173af1c812a63a8723addabac023d\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/OnlyWethReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./EthReceiver.sol\\\";\\n\\nabstract contract OnlyWethReceiver is EthReceiver {\\n    address private immutable _WETH; // solhint-disable-line var-name-mixedcase\\n\\n    constructor(address weth) {\\n        _WETH = address(weth);\\n    }\\n\\n    function _receive() internal virtual override {\\n        if (msg.sender != _WETH) revert EthDepositRejected();\\n    }\\n}\\n\",\"keccak256\":\"0x6abe0f0423e8682fbeed771dc1c8ab5c7014d6784694d0b9334327ec716318b3\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/interfaces/IDaiLikePermit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IDaiLikePermit {\\n    function permit(\\n        address holder,\\n        address spender,\\n        uint256 nonce,\\n        uint256 expiry,\\n        bool allowed,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\",\"keccak256\":\"0xbbb219886412a339a7f84b0850f700311dd2b3a106919ae54fa0a215d847a3b2\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/interfaces/IPermit2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IPermit2 {\\n    struct PermitDetails {\\n        // ERC20 token address\\n        address token;\\n        // the maximum amount allowed to spend\\n        uint160 amount;\\n        // timestamp at which a spender's token allowances become invalid\\n        uint48 expiration;\\n        // an incrementing value indexed per owner,token,and spender for each signature\\n        uint48 nonce;\\n    }\\n    /// @notice The permit message signed for a single token allownce\\n    struct PermitSingle {\\n        // the permit data for a single token alownce\\n        PermitDetails details;\\n        // address permissioned on the allowed tokens\\n        address spender;\\n        // deadline on the permit signature\\n        uint256 sigDeadline;\\n    }\\n    /// @notice Packed allowance\\n    struct PackedAllowance {\\n        // amount allowed\\n        uint160 amount;\\n        // permission expiry\\n        uint48 expiration;\\n        // an incrementing value indexed per owner,token,and spender for each signature\\n        uint48 nonce;\\n    }\\n\\n    function transferFrom(address user, address spender, uint160 amount, address token) external;\\n\\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\\n\\n    function allowance(address user, address token, address spender) external view returns (PackedAllowance memory);\\n}\\n\",\"keccak256\":\"0x63209a082f66ecb584b86e412b3dd0010e9675bc19bc1f80a75437311df7ec11\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/interfaces/IWETH.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IWETH is IERC20 {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 amount) external;\\n}\\n\",\"keccak256\":\"0x048a69d5bb1238cafcc67dbda5a530dcd9236e6e8c963765089655b85cb0fc7a\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/libraries/RevertReasonForwarder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @title Revert reason forwarder.\\nlibrary RevertReasonForwarder {\\n    /// @dev Forwards latest externall call revert.\\n    function reRevert() internal pure {\\n        // bubble up revert reason from latest external call\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let ptr := mload(0x40)\\n            returndatacopy(ptr, 0, returndatasize())\\n            revert(ptr, returndatasize())\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x953c4a195ae066e90aac2ccfcef3121e4c5b74f2cf7cb4add341a7df7df2d00e\",\"license\":\"MIT\"},\"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../interfaces/IDaiLikePermit.sol\\\";\\nimport \\\"../interfaces/IPermit2.sol\\\";\\nimport \\\"../interfaces/IWETH.sol\\\";\\nimport \\\"../libraries/RevertReasonForwarder.sol\\\";\\n\\n/// @title Implements efficient safe methods for ERC20 interface.\\nlibrary SafeERC20 {\\n    error SafeTransferFailed();\\n    error SafeTransferFromFailed();\\n    error ForceApproveFailed();\\n    error SafeIncreaseAllowanceFailed();\\n    error SafeDecreaseAllowanceFailed();\\n    error SafePermitBadLength();\\n    error Permit2TransferAmountTooHigh();\\n\\n    address private constant _PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\\n    bytes4 private constant _PERMIT_LENGTH_ERROR = 0x68275857;  // SafePermitBadLength.selector\\n    uint256 private constant _RAW_CALL_GAS_LIMIT = 5000;\\n\\n    function safeBalanceOf(\\n        IERC20 token,\\n        address account\\n    ) internal view returns(uint256 tokenBalance) {\\n        bytes4 selector = IERC20.balanceOf.selector;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            mstore(0x00, selector)\\n            mstore(0x04, account)\\n            let success := staticcall(gas(), token, 0x00, 0x24, 0x00, 0x20)\\n            tokenBalance := mload(0)\\n\\n            if or(iszero(success), lt(returndatasize(), 0x20)) {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /// @dev Ensures method do not revert or return boolean `true`, admits call to non-smart-contract.\\n    function safeTransferFromUniversal(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bool permit2\\n    ) internal {\\n        if (permit2) {\\n            safeTransferFromPermit2(token, from, to, amount);\\n        } else {\\n            safeTransferFrom(token, from, to, amount);\\n        }\\n    }\\n\\n    /// @dev Ensures method do not revert or return boolean `true`, admits call to non-smart-contract.\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bytes4 selector = token.transferFrom.selector;\\n        bool success;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let data := mload(0x40)\\n\\n            mstore(data, selector)\\n            mstore(add(data, 0x04), from)\\n            mstore(add(data, 0x24), to)\\n            mstore(add(data, 0x44), amount)\\n            success := call(gas(), token, 0, data, 100, 0x0, 0x20)\\n            if success {\\n                switch returndatasize()\\n                case 0 {\\n                    success := gt(extcodesize(token), 0)\\n                }\\n                default {\\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\\n                }\\n            }\\n        }\\n        if (!success) revert SafeTransferFromFailed();\\n    }\\n\\n    /// @dev Permit2 version of safeTransferFrom above.\\n    function safeTransferFromPermit2(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        if (amount > type(uint160).max) revert Permit2TransferAmountTooHigh();\\n        bytes4 selector = IPermit2.transferFrom.selector;\\n        bool success;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let data := mload(0x40)\\n\\n            mstore(data, selector)\\n            mstore(add(data, 0x04), from)\\n            mstore(add(data, 0x24), to)\\n            mstore(add(data, 0x44), amount)\\n            mstore(add(data, 0x64), token)\\n            success := call(gas(), _PERMIT2, 0, data, 0x84, 0x0, 0x0)\\n            if success {\\n                success := gt(extcodesize(_PERMIT2), 0)\\n            }\\n        }\\n        if (!success) revert SafeTransferFromFailed();\\n    }\\n\\n    /// @dev Ensures method do not revert or return boolean `true`, admits call to non-smart-contract.\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        if (!_makeCall(token, token.transfer.selector, to, value)) {\\n            revert SafeTransferFailed();\\n        }\\n    }\\n\\n    /// @dev If `approve(from, to, amount)` fails, try to `approve(from, to, 0)` before retry.\\n    function forceApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        if (!_makeCall(token, token.approve.selector, spender, value)) {\\n            if (\\n                !_makeCall(token, token.approve.selector, spender, 0) ||\\n                !_makeCall(token, token.approve.selector, spender, value)\\n            ) {\\n                revert ForceApproveFailed();\\n            }\\n        }\\n    }\\n\\n    /// @dev Allowance increase with safe math check.\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 allowance = token.allowance(address(this), spender);\\n        if (value > type(uint256).max - allowance) revert SafeIncreaseAllowanceFailed();\\n        forceApprove(token, spender, allowance + value);\\n    }\\n\\n    /// @dev Allowance decrease with safe math check.\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 allowance = token.allowance(address(this), spender);\\n        if (value > allowance) revert SafeDecreaseAllowanceFailed();\\n        forceApprove(token, spender, allowance - value);\\n    }\\n\\n    function safePermit(IERC20 token, bytes calldata permit) internal {\\n        if (!tryPermit(token, msg.sender, address(this), permit)) RevertReasonForwarder.reRevert();\\n    }\\n\\n    function safePermit(IERC20 token, address owner, address spender, bytes calldata permit) internal {\\n        if (!tryPermit(token, owner, spender, permit)) RevertReasonForwarder.reRevert();\\n    }\\n\\n    function tryPermit(IERC20 token, bytes calldata permit) internal returns(bool success) {\\n        return tryPermit(token, msg.sender, address(this), permit);\\n    }\\n\\n    function tryPermit(IERC20 token, address owner, address spender, bytes calldata permit) internal returns(bool success) {\\n        bytes4 permitSelector = IERC20Permit.permit.selector;\\n        bytes4 daiPermitSelector = IDaiLikePermit.permit.selector;\\n        bytes4 permit2Selector = IPermit2.permit.selector;\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let ptr := mload(0x40)\\n            switch permit.length\\n            case 100 {\\n                mstore(ptr, permitSelector)\\n                mstore(add(ptr, 0x04), owner)\\n                mstore(add(ptr, 0x24), spender)\\n\\n                // Compact IERC20Permit.permit(uint256 value, uint32 deadline, uint256 r, uint256 vs)\\n                {  // stack too deep\\n                    let deadline := shr(224, calldataload(add(permit.offset, 0x20)))\\n                    let vs := calldataload(add(permit.offset, 0x44))\\n\\n                    calldatacopy(add(ptr, 0x44), permit.offset, 0x20) // value\\n                    mstore(add(ptr, 0x64), sub(deadline, 1))\\n                    mstore(add(ptr, 0x84), add(27, shr(255, vs)))\\n                    calldatacopy(add(ptr, 0xa4), add(permit.offset, 0x24), 0x20) // r\\n                    mstore(add(ptr, 0xc4), shr(1, shl(1, vs)))\\n                }\\n                // IERC20Permit.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\\n            }\\n            case 72 {\\n                mstore(ptr, daiPermitSelector)\\n                mstore(add(ptr, 0x04), owner)\\n                mstore(add(ptr, 0x24), spender)\\n\\n                // Compact IDaiLikePermit.permit(uint32 nonce, uint32 expiry, uint256 r, uint256 vs)\\n                {  // stack too deep\\n                    let expiry := shr(224, calldataload(add(permit.offset, 0x04)))\\n                    let vs := calldataload(add(permit.offset, 0x28))\\n\\n                    mstore(add(ptr, 0x44), shr(224, calldataload(permit.offset)))\\n                    mstore(add(ptr, 0x64), sub(expiry, 1))\\n                    mstore(add(ptr, 0x84), true)\\n                    mstore(add(ptr, 0xa4), add(27, shr(255, vs)))\\n                    calldatacopy(add(ptr, 0xc4), add(permit.offset, 0x08), 0x20) // r\\n                    mstore(add(ptr, 0xe4), shr(1, shl(1, vs)))\\n                }\\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\\n            }\\n            case 224 {\\n                mstore(ptr, permitSelector)\\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length)\\n                // IERC20Permit.permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\\n                success := call(gas(), token, 0, ptr, 0xe4, 0, 0)\\n            }\\n            case 256 {\\n                mstore(ptr, daiPermitSelector)\\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length)\\n                // IDaiLikePermit.permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s)\\n                success := call(gas(), token, 0, ptr, 0x104, 0, 0)\\n            }\\n            case 96 {\\n                // Compact IPermit2.permit(uint160 amount, uint32 expiration, uint32 nonce, uint32 sigDeadline, uint256 r, uint256 vs)\\n                mstore(ptr, permit2Selector)\\n                mstore(add(ptr, 0x04), owner)\\n                mstore(add(ptr, 0x24), token)\\n                calldatacopy(add(ptr, 0x50), permit.offset, 0x14) // amount\\n                mstore(add(ptr, 0x64), and(0xffffffffffff, sub(shr(224, calldataload(add(permit.offset, 0x14))), 1))) // expiration\\n                mstore(add(ptr, 0x84), shr(224, calldataload(add(permit.offset, 0x18)))) // nonce\\n                mstore(add(ptr, 0xa4), spender)\\n                mstore(add(ptr, 0xc4), and(0xffffffffffff, sub(shr(224, calldataload(add(permit.offset, 0x1c))), 1))) // sigDeadline\\n                mstore(add(ptr, 0xe4), 0x100)\\n                mstore(add(ptr, 0x104), 0x40)\\n                calldatacopy(add(ptr, 0x124), add(permit.offset, 0x20), 0x20) // r\\n                calldatacopy(add(ptr, 0x144), add(permit.offset, 0x40), 0x20) // vs\\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\\n                success := call(gas(), _PERMIT2, 0, ptr, 0x164, 0, 0)\\n            }\\n            case 352 {\\n                mstore(ptr, permit2Selector)\\n                calldatacopy(add(ptr, 0x04), permit.offset, permit.length)\\n                // IPermit2.permit(address owner, PermitSingle calldata permitSingle, bytes calldata signature)\\n                success := call(gas(), _PERMIT2, 0, ptr, 0x164, 0, 0)\\n            }\\n            default {\\n                mstore(ptr, _PERMIT_LENGTH_ERROR)\\n                revert(ptr, 4)\\n            }\\n        }\\n    }\\n\\n    function _makeCall(\\n        IERC20 token,\\n        bytes4 selector,\\n        address to,\\n        uint256 amount\\n    ) private returns (bool success) {\\n        assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n            let data := mload(0x40)\\n\\n            mstore(data, selector)\\n            mstore(add(data, 0x04), to)\\n            mstore(add(data, 0x24), amount)\\n            success := call(gas(), token, 0, data, 0x44, 0x0, 0x20)\\n            if success {\\n                switch returndatasize()\\n                case 0 {\\n                    success := gt(extcodesize(token), 0)\\n                }\\n                default {\\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\\n                }\\n            }\\n        }\\n    }\\n\\n    function safeDeposit(IWETH weth, uint256 amount) internal {\\n        if (amount > 0) {\\n            bytes4 selector = IWETH.deposit.selector;\\n            assembly (\\\"memory-safe\\\") { // solhint-disable-line no-inline-assembly\\n                mstore(0, selector)\\n                if iszero(call(gas(), weth, amount, 0, 4, 0, 0)) {\\n                    returndatacopy(0, 0, returndatasize())\\n                    revert(0, returndatasize())\\n                }\\n            }\\n        }\\n    }\\n\\n    function safeWithdraw(IWETH weth, uint256 amount) internal {\\n        bytes4 selector = IWETH.withdraw.selector;\\n        assembly (\\\"memory-safe\\\") {  // solhint-disable-line no-inline-assembly\\n            mstore(0, selector)\\n            mstore(4, amount)\\n            if iszero(call(gas(), weth, 0, 0, 0x24, 0, 0)) {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n        }\\n    }\\n\\n    function safeWithdrawTo(IWETH weth, uint256 amount, address to) internal {\\n        safeWithdraw(weth, amount);\\n        if (to != address(this)) {\\n            assembly (\\\"memory-safe\\\") {  // solhint-disable-line no-inline-assembly\\n                if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\\n                    let ptr := mload(0x40)\\n                    returndatacopy(ptr, 0, returndatasize())\\n                    revert(ptr, returndatasize())\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5d03e4b11e5a429c2530120527988678d499550e4e19be4420a69e0eae5c5203\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xec63854014a5b4f2b3290ab9103a21bdf902a508d0f41a8573fea49e98bf571a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// EIP-2612 is Final as of 2022-11-01. This file is deprecated.\\n\\nimport \\\"./IERC20Permit.sol\\\";\\n\",\"keccak256\":\"0xc7134e0f63b0adcee02bf4b15efb2d0d4b1c03ae0d127dc90d846da4cab23a76\",\"license\":\"MIT\"},\"contracts/helpers/WethUnwrapper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"@1inch/solidity-utils/contracts/OnlyWethReceiver.sol\\\";\\nimport \\\"@1inch/solidity-utils/contracts/interfaces/IWETH.sol\\\";\\nimport \\\"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\\\";\\n\\ncontract WethUnwrapper is OnlyWethReceiver {\\n    using SafeERC20 for IWETH;\\n\\n    IWETH private immutable _WETH;  // solhint-disable-line var-name-mixedcase\\n\\n    constructor(IWETH weth) OnlyWethReceiver(address(weth)) {\\n        _WETH = weth;\\n    }\\n\\n    // Limit Order Protocol V3 support\\n    function fillOrderPostInteraction(\\n        bytes32 /* orderHash */,\\n        address maker,\\n        address /* taker */,\\n        uint256 /* makingAmount */,\\n        uint256 takingAmount,\\n        uint256 /* remainingMakerAmount */,\\n        bytes calldata interactiveData\\n    ) external {\\n        address receiver = maker;\\n        if (interactiveData.length == 20) {\\n            receiver = address(bytes20(interactiveData));\\n        }\\n        _WETH.safeWithdrawTo(takingAmount, receiver);\\n    }\\n}\\n\",\"keccak256\":\"0x85e4f16daeef63edc7f21d2cc204c21183ad1df548cd8a40882a78f96c9ec369\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60c03461007657601f61027838819003918201601f19168301916001600160401b0383118484101761007b5780849260209460405283398101031261007657516001600160a01b0381168082036100765760805260a0526040516101e69081610092823960805181601b015260a051816101040152f35b600080fd5b634e487b7160e01b600052604160045260246000fdfe6080604052600436101561005d575b361561001957600080fd5b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316330361004b57005b604051631b10b0f960e01b8152600490fd5b6000803560e01c633504ed6214610074575061000e565b346101ad5760e03660031901126101ad57806024356001600160a01b0380821682036101a957604435818116036101a9576084359060c4359267ffffffffffffffff908185116101a557366023860112156101a55784600401359182116101a55736602483870101116101a557936014821461015e575b5050632e1a7d4d60e01b845260048290528380602481807f00000000000000000000000000000000000000000000000000000000000000005af115610153573090831603610137575050f35b8280929181925af1156101475780f35b604051903d90823e3d90fd5b6040513d85823e3d90fd5b9193506bffffffffffffffffffffffff1991602401358281169160148110610190575b5050905060601c9138806100eb565b8391925060140360031b1b1616803880610181565b8580fd5b5050fd5b80fdfea26469706673582212200fc3598d9d78462cdab92de7396d108aa15dcd595c7316e41bfc22d004d3066c64736f6c63430008130033",
  "deployedBytecode": "0x6080604052600436101561005d575b361561001957600080fd5b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316330361004b57005b604051631b10b0f960e01b8152600490fd5b6000803560e01c633504ed6214610074575061000e565b346101ad5760e03660031901126101ad57806024356001600160a01b0380821682036101a957604435818116036101a9576084359060c4359267ffffffffffffffff908185116101a557366023860112156101a55784600401359182116101a55736602483870101116101a557936014821461015e575b5050632e1a7d4d60e01b845260048290528380602481807f00000000000000000000000000000000000000000000000000000000000000005af115610153573090831603610137575050f35b8280929181925af1156101475780f35b604051903d90823e3d90fd5b6040513d85823e3d90fd5b9193506bffffffffffffffffffffffff1991602401358281169160148110610190575b5050905060601c9138806100eb565b8391925060140360031b1b1616803880610181565b8580fd5b5050fd5b80fdfea26469706673582212200fc3598d9d78462cdab92de7396d108aa15dcd595c7316e41bfc22d004d3066c64736f6c63430008130033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}